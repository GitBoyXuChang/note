## 深拷贝和浅拷贝

浅拷贝和深拷贝
js的内存分配机制
在学习浅拷贝和深拷贝之前，我们要先有堆、栈等数据结构的概念，了解js的内存分配机制

JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。

JS的数据类型
相信大家都知道js的7个数据类型分为：基础类型和引用类型

基础类型： String、Boolean、Number、Null、undefined、symbol(表示独一无二的值)

引用类型： Object (Array、Object、Function)

基础类型
基本类型的键值都存储在栈内存中

### 浅拷贝：

对基本类型和引用类型只进行值的拷贝，即，拷贝引用对象的时候，只对引用对象的内存地址拷贝，新旧引用属性指向同一个对象，修改任意一个都会影响所有引用当前对象的变量。

先看 数组类型：

```js
let list_a = [1, 2, 3, 4, 5]
let list_b = list_a
console.log('赋值前：', list_a, list_b)
list_b[0] = 11
console.log('赋值后：', list_a, list_b)
```



结果输出：

赋值前： (5) [1, 2, 3, 4, 5] (5) [1, 2, 3, 4, 5]
赋值后： (5) [11, 2, 3, 4, 5] (5) [11, 2, 3, 4, 5]

可以看到，当我们改变list_b后，list_a的值也跟着变了，当然了，这并不是很奇怪，奇怪的是，为什么上面的基础类型的值得变化和这里的不同呢？

实际上，当我们执行 list_b = list_a 时，它的堆栈变化是这样的：

栈中：

name	value
list_a	5B540
list_b	5B540

堆中:

name	value
5B540	[1, 2, 3, 4, 5]

这样我们可以看出，list_a和list_b的地址是相同的，都是指向堆中同一个值。就好像人的外号一样，不管他有几个外号，人就是那一个。

而这就是----浅拷贝！

### 深拷贝：

对引用类型所引用的对象也进行拷贝。使得新旧引用属性指向不同的对象，达到两者状态分离的效果。

栈中：

name	value
list_a	5B540
list_b	4B2540
堆中:

name	value
5B540	[1, 2, 3, 4, 5]
4B2540	[1, 2, 3, 4, 5]
这就是深拷贝，和浅拷贝不同，深拷贝会把值拷贝在堆中，使list_a和list_b两个互不影响独立存在。注意他们在栈中的内存地址是不同的。

有时候，我们对引用类型的值进行操作时，可能会更改它的值或属性，但是那样又会影响别的地方对该值的使用。我们不希望这样，这时候就可以通过深拷贝复制一份，在不影响原值的情况下完成我们想要的操作。所以深拷贝的实现有时是很必要的!

以上就是今天要介绍的内容：简单介绍了一下浅拷贝和深拷贝及它们的区别

以后有时间再看一下深拷贝的实现及实际应用
